<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>ä¹ä¹ä¹˜æ³•è¡¨å°„å‡»æ¸¸æˆ</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none; /* ç¦æ­¢é€‰ä¸­æ–‡æœ¬ */
        -webkit-user-select: none;
        touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º */
      }

      body {
        background-color: #2c3e50;
        overflow: hidden; /* é˜²æ­¢æ»šåŠ¨ */
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      canvas {
        display: block;
        margin: 0 auto;
        background: linear-gradient(to bottom, #87ceeb, #e0f7fa); /* å¤©ç©ºèƒŒæ™¯ */
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°canvas */
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* ç®€å•çš„UIè¦†ç›–å±‚ï¼Œä»…åœ¨æ¸¸æˆç»“æŸæ—¶æ˜¾ç¤ºäº¤äº’ */
      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none; /* é»˜è®¤éšè— */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        pointer-events: auto; /* å…è®¸ç‚¹å‡» */
        z-index: 10;
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 20px;
        color: #ffd700;
        text-shadow: 2px 2px 4px #000;
      }

      p {
        font-size: 1.5rem;
        color: #fff;
      }

      .blink {
        animation: blinker 1.5s linear infinite;
      }

      @keyframes blinker {
        50% {
          opacity: 0;
        }
      }
      /* UI æŒ‰é’®æ ·å¼ */
      .btn {
        background: #ffd700;
        border: none;
        padding: 15px 30px;
        margin: 10px;
        font-size: 1.2rem;
        border-radius: 50px;
        cursor: pointer;
        box-shadow: 0 4px 0 #d4b100;
        transition: all 0.1s;
        font-family: inherit;
        width: 220px;
        color: #333;
        font-weight: bold;
        display: block;
      }
      .btn:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #d4b100;
      }
      .btn-group {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, #2c3e50, #3498db);
        display: flex; /* é»˜è®¤æ˜¾ç¤º */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 20;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <div id="start-screen">
      <h1>ä¹ä¹ä¹˜æ³•è¡¨<br />å°„å‡»æ¸¸æˆ</h1>
      <p style="margin-bottom: 30px">é€‰æ‹©éš¾åº¦å¼€å§‹</p>
      <div class="btn-group">
        <button class="btn" onclick="startGame('slow')">ğŸ¢ æ…¢é€Ÿ (ç®€å•)</button>
        <button class="btn" onclick="startGame('medium')">
          ğŸš¶ ä¸­é€Ÿ (æ™®é€š)
        </button>
        <button class="btn" onclick="startGame('fast')">ğŸš€ å¿«é€Ÿ (å›°éš¾)</button>
      </div>
    </div>

    <div id="game-over-screen">
      <h1>æ¸¸æˆç»“æŸ!</h1>
      <p>æœ€ç»ˆå¾—åˆ†: <span id="final-score">0</span></p>
      <p class="blink" style="margin-top: 30px; font-size: 1.2rem">
        ç‚¹å‡»æˆ–è§¦æ‘¸å±å¹•ä»»æ„ä½ç½®é‡æ–°å¼€å§‹
      </p>
    </div>

    <script>
      /**
       * æ¸¸æˆé…ç½®ä¸å…¨å±€å˜é‡
       */

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const gameOverScreen = document.getElementById("game-over-screen");
      const startScreen = document.getElementById("start-screen");
      const finalScoreSpan = document.getElementById("final-score");

      const difficultySettings = {
        slow: { baseSpeed: 25, speedVar: 15, interval: 3000 },
        medium: { baseSpeed: 50, speedVar: 30, interval: 2200 },
        fast: { baseSpeed: 90, speedVar: 50, interval: 1500 },
      };
      let currentDifficulty = "medium";

      // æ¸¸æˆçŠ¶æ€
      let gameState = "playing"; // playing, gameover
      let score = 0;
      let lastTime = 0;
      let enemySpawnTimer = 0;
      let enemySpawnInterval = 500; // è¿™é‡Œçš„é—´éš”æ˜¯å½“å‰æ°”çƒæ¶ˆå¤±åå¤šä¹…ç”Ÿæˆä¸‹ä¸€ä¸ª

      // å®ä½“å®¹å™¨
      let enemies = [];
      let bullets = [];
      let particles = []; // çˆ†ç‚¸ç²’å­

      // å±å¹•å°ºå¯¸ç®¡ç†
      let outputScale = window.devicePixelRatio || 1;

      function resize() {
        // ä¿æŒç«–å±æ¯”ä¾‹æˆ–å…¨å±ï¼Œè¿™é‡Œåšç®€å•å…¨å±é€‚é…ï¼Œä½†é™åˆ¶æœ€å¤§å®½åº¦ä»¥å…åœ¨å®½å±ä¸Šå¤ªéš¾
        const maxWidth = 600;
        const isMobile = window.innerWidth < 800;

        let w = window.innerWidth;
        let h = window.innerHeight;

        if (!isMobile && w > maxWidth) {
          w = maxWidth;
        }

        canvas.width = w * outputScale;
        canvas.height = h * outputScale;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";

        // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡ï¼Œä¿è¯æ¸…æ™°åº¦
        ctx.scale(outputScale, outputScale);
      }

      window.addEventListener("resize", resize);
      resize();

      /**
       * ç±»å®šä¹‰
       */

      class Bullet {
        constructor(startX, startY, targetEnemy) {
          this.x = startX;
          this.y = startY;
          this.target = targetEnemy;
          this.speed = 800; // åƒç´ /ç§’
          this.active = true;
          this.radius = 6;

          // è®¡ç®—åˆå§‹æ–¹å‘ï¼Œè™½ç„¶æˆ‘ä»¬ä¼šè¿½è¸ªç›®æ ‡
          const dx = targetEnemy.x - startX;
          const dy = targetEnemy.y - startY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          this.vx = (dx / dist) * this.speed;
          this.vy = (dy / dist) * this.speed;
        }

        update(dt) {
          if (!this.active) return;

          // å¦‚æœç›®æ ‡è¿˜åœ¨ï¼Œæ›´æ–°ç›®æ ‡ä½ç½®ä½œä¸ºè¿½è¸ªæ–¹å‘ï¼ˆç®€å•çš„è¿½è¸ªå¯¼å¼¹æ•ˆæœï¼Œæˆ–è€…ç›´çº¿é£ä¹Ÿå¯ï¼‰
          // è¿™é‡Œä¸ºäº†æ‰“å‡»æ„Ÿï¼Œä½¿ç”¨ç›´çº¿é£å‘å½“å‰ç›®æ ‡çš„ä½ç½®
          if (this.target && this.target.active) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 20) {
              // å‡»ä¸­åˆ¤å®š
              this.hit();
              return;
            }

            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
          }

          this.x += this.vx * dt;
          this.y += this.vy * dt;

          // è¾¹ç•Œæ£€æŸ¥
          if (this.y < 0 || this.x < 0 || this.x > canvas.width / outputScale) {
            this.active = false;
          }
        }

        hit() {
          this.active = false;
          if (this.target && this.target.active) {
            this.target.takeDamage();
            // çˆ†ç‚¸ç‰¹æ•ˆ
            createExplosion(this.target.x, this.target.y, this.target.color);
          }
        }

        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#FFFF00";
          ctx.fill();
          ctx.strokeStyle = "#FFA500";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      class Enemy {
        constructor() {
          // æ¸¸æˆé€»è¾‘å°ºå¯¸
          const stageWidth = canvas.width / outputScale;

          this.radius = 40;
          // ç¡®ä¿æ°”çƒå®Œå…¨åœ¨å±å¹•å†…
          // æŒ‰é’®æ€»å®½åº¦è®¡ç®—: 3*50 + 2*10 = 170, åŠå®½ 85
          // æ°”çƒåŠå¾„ 40
          // éœ€è¦ç¡®ä¿ x - 85 >= 0 ä¸” x + 85 <= stageWidth
          const safeMargin = 90; // 85 + 5px è¾¹è·
          this.x = Math.random() * (stageWidth - safeMargin * 2) + safeMargin;
          this.y = -this.radius * 2; // ä»å±å¹•ä¸Šæ–¹å¼€å§‹

          // éšæœºç”Ÿæˆé€Ÿåº¦
          const cfg = difficultySettings[currentDifficulty];
          this.speed = cfg.baseSpeed + Math.random() * cfg.speedVar; // åƒç´ /ç§’

          this.active = true;
          this.color = `hsl(${Math.random() * 360}, 70%, 60%)`; // éšæœºæŸ”å’Œé¢œè‰²

          // ç”Ÿæˆç®—æœ¯é¢˜
          this.numA = Math.floor(Math.random() * 9) + 1;
          this.numB = Math.floor(Math.random() * 9) + 1;
          this.answer = this.numA * this.numB;
          this.questionText = `${this.numA} Ã— ${this.numB}`;

          // ç”Ÿæˆé€‰é¡¹
          this.options = [];
          this.generateOptions();
        }

        generateOptions() {
          const correct = this.answer;
          // ç”Ÿæˆä¸¤ä¸ªé”™è¯¯çš„ç­”æ¡ˆ
          let wrong1 = this.generateWrongAnswer(correct);
          let wrong2 = this.generateWrongAnswer(correct, wrong1);

          const opts = [
            { val: correct, isCorrect: true },
            { val: wrong1, isCorrect: false },
            { val: wrong2, isCorrect: false },
          ];

          // æ‰“ä¹±é¡ºåº
          for (let i = opts.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [opts[i], opts[j]] = [opts[j], opts[i]];
          }

          this.optionData = opts;
        }

        generateWrongAnswer(correct, exclude) {
          let wrong;
          do {
            // é”™è¯¯ç­”æ¡ˆåœ¨ æ­£ç¡®ç­”æ¡ˆ +/- 10 èŒƒå›´å†…ï¼Œæˆ–è€…æ˜¯ä¸ªä½æ•°ä¹˜æ³•çš„å¸¸è§é”™è¯¯
            const offset = Math.floor(Math.random() * 10) - 5;
            wrong = correct + offset;
            if (wrong <= 0) wrong = 1;
          } while (wrong === correct || wrong === exclude);
          return wrong;
        }

        update(dt) {
          if (!this.active) return;

          // åŠ¨æ€è°ƒæ•´ X ä½ç½®ä»¥é˜²æ­¢çª—å£æ”¹å˜æ—¶æº¢å‡º
          const stageWidth = canvas.width / outputScale;
          const safeMargin = 95;
          if (this.x < safeMargin) this.x = safeMargin;
          if (this.x > stageWidth - safeMargin)
            this.x = stageWidth - safeMargin;

          this.y += this.speed * dt;

          const stageHeight = canvas.height / outputScale;
          // è§¦åº•æ£€æµ‹ - æ¸¸æˆç»“æŸæ¡ä»¶
          // æ°”çƒæœ¬ä½“è§¦åº•å°±ç®—è¾“
          if (this.y - this.radius > stageHeight) {
            triggerGameOver();
          }
        }

        takeDamage() {
          this.active = false;
          score++;
          // å¯ä»¥åœ¨è¿™é‡Œæ’­æ”¾éŸ³æ•ˆ
        }

        // æ—§é€»è¾‘å·²åºŸå¼ƒï¼Œç°åœ¨ä½¿ç”¨å…¨å±€UI

        draw(ctx) {
          // ç»˜åˆ¶æ°”çƒç»³å­
          ctx.beginPath();
          ctx.moveTo(this.x, this.y + this.radius);
          ctx.lineTo(this.x, this.y + this.radius + 60);
          ctx.strokeStyle = "#ddd";
          ctx.lineWidth = 1;
          ctx.stroke();

          // ç»˜åˆ¶æ°”çƒæœ¬ä½“
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          // é«˜å…‰
          ctx.beginPath();
          ctx.arc(
            this.x - this.radius * 0.3,
            this.y - this.radius * 0.3,
            this.radius * 0.2,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "rgba(255,255,255,0.3)";
          ctx.fill();

          // ç»˜åˆ¶ç®—å¼
          ctx.fillStyle = "white";
          ctx.font = "bold 24px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.questionText, this.x, this.y);

          // æ³¨æ„ï¼šé€‰é¡¹ä¸å†è·Ÿéšæ°”çƒç»˜åˆ¶
        }
      }

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 100 + 50;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.life = 1.0; // ç”Ÿå‘½å€¼ 1.0 -> 0
          this.decay = Math.random() * 1.5 + 0.5; // æ¯ç§’è¡°å‡
        }

        update(dt) {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.life -= this.decay * dt;
        }

        draw(ctx) {
          ctx.globalAlpha = Math.max(0, this.life);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
          particles.push(new Particle(x, y, color));
        }
      }

      /**
       * æ¸¸æˆä¸»å¾ªç¯é€»è¾‘
       */

      function startGame(difficulty) {
        if (difficulty) {
          currentDifficulty = difficulty;
        }

        // åº”ç”¨éš¾åº¦è®¾ç½®
        // åº”ç”¨éš¾åº¦è®¾ç½® - è®¾ç½®ä¸ºå¾ˆçŸ­çš„ç”Ÿæˆé—´éš”ï¼Œå› ä¸ºæˆ‘ä»¬è¦ç­‰ä¸Šä¸€ä¸ªæ¶ˆå¤±æ‰ç”Ÿæˆ
        enemySpawnInterval = 500;

        gameState = "playing";
        score = 0;
        enemies = [];
        bullets = [];
        particles = [];
        enemySpawnTimer = 0;
        lastTime = performance.now();
        gameOverScreen.style.display = "none";
        startScreen.style.display = "none";
        requestAnimationFrame(gameLoop);
      }

      function triggerGameOver() {
        if (gameState === "gameover") return;
        gameState = "gameover";
        finalScoreSpan.textContent = score;
        gameOverScreen.style.display = "flex";
      }

      function gameLoop(timestamp) {
        if (gameState !== "playing") return;

        const dt = (timestamp - lastTime) / 1000; // è½¬æ¢ä¸ºç§’
        lastTime = timestamp;

        update(dt);
        draw();

        requestAnimationFrame(gameLoop);
      }

      function update(dt) {
        // ç”Ÿæˆæ•Œäºº
        // ç”Ÿæˆæ•Œäºº (å•ä¸€æ•Œäººæ¨¡å¼)
        if (enemies.length === 0) {
          enemySpawnTimer += dt * 1000;
          if (enemySpawnTimer > enemySpawnInterval) {
            enemies.push(new Enemy());
            enemySpawnTimer = 0;
          }
        }

        // æ›´æ–°æ•Œäºº
        enemies.forEach((e) => e.update(dt));
        enemies = enemies.filter((e) => e.active);

        // æ›´æ–°å­å¼¹
        bullets.forEach((b) => b.update(dt));
        bullets = bullets.filter((b) => b.active);

        // æ›´æ–°ä¾‹å­
        particles.forEach((p) => p.update(dt));
        particles = particles.filter((p) => p.life > 0);
      }

      function draw() {
        // é€»è¾‘å¤§å°
        const stageWidth = canvas.width / outputScale;
        const stageHeight = canvas.height / outputScale;

        // æ¸…ç©º
        ctx.clearRect(0, 0, stageWidth, stageHeight);

        // ç»˜åˆ¶ç‚®å° (ç®€å•çš„åº•éƒ¨å±…ä¸­)
        const turretX = stageWidth / 2;
        const turretY = stageHeight - 120; // ç‚®å°å‘ä¸Šç§»åŠ¨ï¼Œç»™åº•éƒ¨æŒ‰é’®ç•™ç©ºé—´

        // ç‚®å°åº•åº§
        ctx.fillStyle = "#555";
        ctx.fillRect(turretX - 30, turretY, 60, 40);
        // ç‚®ç®¡
        ctx.fillStyle = "#333";
        ctx.fillRect(turretX - 10, turretY - 30, 20, 40);

        // ç»˜åˆ¶å®ä½“
        enemies.forEach((e) => e.draw(ctx));
        bullets.forEach((b) => b.draw(ctx));
        particles.forEach((p) => p.draw(ctx));

        // ç»˜åˆ¶åº•éƒ¨ UI æŒ‰é’®
        if (enemies.length > 0) {
          drawBottomUI(ctx, enemies[0]);
        }

        // ç»˜åˆ¶ UI
        ctx.fillStyle = "#333";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`å¾—åˆ†: ${score}`, 20, 20);
      }

      function drawBottomUI(ctx, enemy) {
        const stageWidth = canvas.width / outputScale;
        const stageHeight = canvas.height / outputScale;

        const boxW = 100; // æ›´å®½çš„æŒ‰é’®
        const boxH = 60;
        const gap = 20;
        const totalW = 3 * boxW + 2 * gap;
        const startX = (stageWidth - totalW) / 2;
        const startY = stageHeight - 80;

        ctx.font = "bold 28px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        enemy.optionData.forEach((opt, i) => {
          const x = startX + i * (boxW + gap);
          const y = startY;

          // æŒ‰é’®èƒŒæ™¯
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.roundRect(x, y, boxW, boxH, 10);
          ctx.fill();

          // è¾¹æ¡†
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 3;
          ctx.stroke();

          // é€‰é¡¹æ•°å­—
          ctx.fillStyle = "#333";
          ctx.fillText(opt.val, x + boxW / 2, y + boxH / 2);
        });
      }

      /**
       * è¾“å…¥å¤„ç†
       */
      function handleInput(e) {
        if (gameState === "gameover") {
          startGame();
          return;
        }

        let clientX, clientY;
        if (e.type === "touchstart") {
          // é˜»æ­¢é»˜è®¤è¡Œä¸ºé˜²æ­¢åŒå‡»ç¼©æ”¾ç­‰
          // e.preventDefault(); // æ³¨æ„ï¼šè¿™å¯èƒ½ä¼šé˜»æ­¢æŸäº›æµè§ˆå™¨çš„ç‚¹å‡»ï¼Œä½†åœ¨canvasæ¸¸æˆä¸­é€šå¸¸éœ€è¦
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        // è½¬æ¢åæ ‡åˆ° Canvas åæ ‡ç³»
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width / outputScale;
        const scaleY = canvas.height / rect.height / outputScale;

        const inputX = (clientX - rect.left) * scaleX;
        const inputY = (clientY - rect.top) * scaleY;

        // æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†åº•éƒ¨æŒ‰é’®
        if (enemies.length === 0) return;

        const enemy = enemies[0];

        const stageWidth = canvas.width / outputScale;
        const stageHeight = canvas.height / outputScale;

        const boxW = 100;
        const boxH = 60;
        const gap = 20;
        const totalW = 3 * boxW + 2 * gap;
        const startX = (stageWidth - totalW) / 2;
        const startY = stageHeight - 80;

        let clickedIndex = -1;

        for (let i = 0; i < 3; i++) {
          const x = startX + i * (boxW + gap);
          const y = startY;

          if (
            inputX >= x &&
            inputX <= x + boxW &&
            inputY >= y &&
            inputY <= y + boxH
          ) {
            clickedIndex = i;
            break;
          }
        }

        if (clickedIndex !== -1) {
          const isCorrect = enemy.optionData[clickedIndex].isCorrect;

          if (isCorrect) {
            // å‘å°„å­å¼¹
            const turretX = stageWidth / 2;
            const turretY = stageHeight - 140; // ç‚®å£ä½ç½®è°ƒæ•´

            bullets.push(new Bullet(turretX, turretY, enemy));
          } else {
            // ç­”é”™äº†
            canvas.style.transform = "translate(5px, 0)";
            setTimeout(() => (canvas.style.transform = "none"), 50);
          }
        }
      }

      // ç»‘å®šäº‹ä»¶
      canvas.addEventListener("mousedown", handleInput);
      canvas.addEventListener("touchstart", handleInput, { passive: false });

      // é‡æ–°å¼€å§‹çš„ç‚¹å‡»ä¾¦å¬ï¼ˆå› ä¸ºé®ç½©å±‚ç›–ä½äº†canvasï¼‰

      function returnToMenu(e) {
        if (e.type === "touchstart") e.preventDefault();
        if (gameState === "gameover") {
          gameOverScreen.style.display = "none";
          startScreen.style.display = "flex";
        }
      }

      gameOverScreen.addEventListener("mousedown", returnToMenu);
      gameOverScreen.addEventListener("touchstart", returnToMenu, {
        passive: false,
      });

      // å¯åŠ¨æ¸¸æˆ
      // æ·»åŠ ä¸€ä¸ªç®€å•çš„ Polyfill roundRect ä»¥é˜²æ—§æµè§ˆå™¨ä¸æ”¯æŒ
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (
          x,
          y,
          w,
          h,
          r
        ) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.beginPath();
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }
    </script>
  </body>
</html>
