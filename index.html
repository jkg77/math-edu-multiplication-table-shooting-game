<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>九九乘法表射击游戏</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none; /* 禁止选中文本 */
        -webkit-user-select: none;
        touch-action: none; /* 禁止默认触摸行为 */
      }

      body {
        background-color: #2c3e50;
        overflow: hidden; /* 防止滚动 */
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      canvas {
        display: block;
        margin: 0 auto;
        background: linear-gradient(to bottom, #87ceeb, #e0f7fa); /* 天空背景 */
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* 让点击穿透到canvas */
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* 简单的UI覆盖层，仅在游戏结束时显示交互 */
      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none; /* 默认隐藏 */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        pointer-events: auto; /* 允许点击 */
        z-index: 10;
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 20px;
        color: #ffd700;
        text-shadow: 2px 2px 4px #000;
      }

      p {
        font-size: 1.5rem;
        color: #fff;
      }

      .blink {
        animation: blinker 1.5s linear infinite;
      }

      @keyframes blinker {
        50% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <div id="game-over-screen">
      <h1>游戏结束!</h1>
      <p>最终得分: <span id="final-score">0</span></p>
      <p class="blink" style="margin-top: 30px; font-size: 1.2rem">
        点击或触摸屏幕任意位置重新开始
      </p>
    </div>

    <script>
      /**
       * 游戏配置与全局变量
       */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const gameOverScreen = document.getElementById("game-over-screen");
      const finalScoreSpan = document.getElementById("final-score");

      // 游戏状态
      let gameState = "playing"; // playing, gameover
      let score = 0;
      let lastTime = 0;
      let enemySpawnTimer = 0;
      let enemySpawnInterval = 2500; // 毫秒

      // 实体容器
      let enemies = [];
      let bullets = [];
      let particles = []; // 爆炸粒子

      // 屏幕尺寸管理
      let outputScale = window.devicePixelRatio || 1;

      function resize() {
        // 保持竖屏比例或全屏，这里做简单全屏适配，但限制最大宽度以免在宽屏上太难
        const maxWidth = 600;
        const isMobile = window.innerWidth < 800;

        let w = window.innerWidth;
        let h = window.innerHeight;

        if (!isMobile && w > maxWidth) {
          w = maxWidth;
        }

        canvas.width = w * outputScale;
        canvas.height = h * outputScale;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";

        // 缩放绘图上下文，保证清晰度
        ctx.scale(outputScale, outputScale);
      }

      window.addEventListener("resize", resize);
      resize();

      /**
       * 类定义
       */

      class Bullet {
        constructor(startX, startY, targetEnemy) {
          this.x = startX;
          this.y = startY;
          this.target = targetEnemy;
          this.speed = 800; // 像素/秒
          this.active = true;
          this.radius = 6;

          // 计算初始方向，虽然我们会追踪目标
          const dx = targetEnemy.x - startX;
          const dy = targetEnemy.y - startY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          this.vx = (dx / dist) * this.speed;
          this.vy = (dy / dist) * this.speed;
        }

        update(dt) {
          if (!this.active) return;

          // 如果目标还在，更新目标位置作为追踪方向（简单的追踪导弹效果，或者直线飞也可）
          // 这里为了打击感，使用直线飞向当前目标的位置
          if (this.target && this.target.active) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 20) {
              // 击中判定
              this.hit();
              return;
            }

            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
          }

          this.x += this.vx * dt;
          this.y += this.vy * dt;

          // 边界检查
          if (this.y < 0 || this.x < 0 || this.x > canvas.width / outputScale) {
            this.active = false;
          }
        }

        hit() {
          this.active = false;
          if (this.target && this.target.active) {
            this.target.takeDamage();
            // 爆炸特效
            createExplosion(this.target.x, this.target.y, this.target.color);
          }
        }

        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#FFFF00";
          ctx.fill();
          ctx.strokeStyle = "#FFA500";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      class Enemy {
        constructor() {
          // 游戏逻辑尺寸
          const stageWidth = canvas.width / outputScale;

          this.radius = 40;
          // 确保气球完全在屏幕内
          this.x = Math.random() * (stageWidth - this.radius * 2) + this.radius;
          this.y = -this.radius * 2; // 从屏幕上方开始

          // 随机生成速度
          this.speed = 40 + Math.random() * 30; // 像素/秒

          this.active = true;
          this.color = `hsl(${Math.random() * 360}, 70%, 60%)`; // 随机柔和颜色

          // 生成算术题
          this.numA = Math.floor(Math.random() * 9) + 1;
          this.numB = Math.floor(Math.random() * 9) + 1;
          this.answer = this.numA * this.numB;
          this.questionText = `${this.numA} × ${this.numB}`;

          // 生成选项
          this.options = [];
          this.generateOptions();
        }

        generateOptions() {
          const correct = this.answer;
          // 生成两个错误的答案
          let wrong1 = this.generateWrongAnswer(correct);
          let wrong2 = this.generateWrongAnswer(correct, wrong1);

          const opts = [
            { val: correct, isCorrect: true },
            { val: wrong1, isCorrect: false },
            { val: wrong2, isCorrect: false },
          ];

          // 打乱顺序
          for (let i = opts.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [opts[i], opts[j]] = [opts[j], opts[i]];
          }

          this.optionData = opts;
        }

        generateWrongAnswer(correct, exclude) {
          let wrong;
          do {
            // 错误答案在 正确答案 +/- 10 范围内，或者是个位数乘法的常见错误
            const offset = Math.floor(Math.random() * 10) - 5;
            wrong = correct + offset;
            if (wrong <= 0) wrong = 1;
          } while (wrong === correct || wrong === exclude);
          return wrong;
        }

        update(dt) {
          if (!this.active) return;
          this.y += this.speed * dt;

          const stageHeight = canvas.height / outputScale;
          // 触底检测 - 游戏结束条件
          // 气球本体触底就算输
          if (this.y - this.radius > stageHeight) {
            triggerGameOver();
          }
        }

        takeDamage() {
          this.active = false;
          score++;
          // 可以在这里播放音效
        }

        // 检查给定的坐标 (inputX, inputY) 是否点击了这个敌人的某个选项
        checkInput(inputX, inputY) {
          if (!this.active) return false;

          // 选项框的相对位置
          // 选项绘制在气球下方
          const boxW = 50;
          const boxH = 30;
          const gap = 10;
          const totalW = 3 * boxW + 2 * gap;
          const startOffset = -totalW / 2;

          for (let i = 0; i < 3; i++) {
            const optX = this.x + startOffset + i * (boxW + gap);
            const optY = this.y + this.radius + 10; // 气球下方

            // 简单的矩形碰撞检测
            if (
              inputX >= optX &&
              inputX <= optX + boxW &&
              inputY >= optY &&
              inputY <= optY + boxH
            ) {
              return this.optionData[i].isCorrect;
            }
          }
          return null; // 没有点中任何选项
        }

        draw(ctx) {
          // 绘制气球绳子
          ctx.beginPath();
          ctx.moveTo(this.x, this.y + this.radius);
          ctx.lineTo(this.x, this.y + this.radius + 60);
          ctx.strokeStyle = "#ddd";
          ctx.lineWidth = 1;
          ctx.stroke();

          // 绘制气球本体
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          // 高光
          ctx.beginPath();
          ctx.arc(
            this.x - this.radius * 0.3,
            this.y - this.radius * 0.3,
            this.radius * 0.2,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "rgba(255,255,255,0.3)";
          ctx.fill();

          // 绘制算式
          ctx.fillStyle = "white";
          ctx.font = "bold 24px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.questionText, this.x, this.y);

          // 绘制选项按钮
          const boxW = 50;
          const boxH = 30;
          const gap = 10;
          const totalW = 3 * boxW + 2 * gap;
          const startOffset = -totalW / 2;

          ctx.font = "16px Arial";

          for (let i = 0; i < 3; i++) {
            const optX = this.x + startOffset + i * (boxW + gap);
            const optY = this.y + this.radius + 10;

            // 按钮背景
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.beginPath();
            ctx.roundRect(optX, optY, boxW, boxH, 5);
            ctx.fill();

            // 边框
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.stroke();

            // 选项数字
            ctx.fillStyle = "#333";
            ctx.fillText(
              this.optionData[i].val,
              optX + boxW / 2,
              optY + boxH / 2
            );
          }
        }
      }

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 100 + 50;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.life = 1.0; // 生命值 1.0 -> 0
          this.decay = Math.random() * 1.5 + 0.5; // 每秒衰减
        }

        update(dt) {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.life -= this.decay * dt;
        }

        draw(ctx) {
          ctx.globalAlpha = Math.max(0, this.life);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
          particles.push(new Particle(x, y, color));
        }
      }

      /**
       * 游戏主循环逻辑
       */

      function startGame() {
        gameState = "playing";
        score = 0;
        enemies = [];
        bullets = [];
        particles = [];
        enemySpawnTimer = 0;
        lastTime = performance.now();
        gameOverScreen.style.display = "none";
        requestAnimationFrame(gameLoop);
      }

      function triggerGameOver() {
        if (gameState === "gameover") return;
        gameState = "gameover";
        finalScoreSpan.textContent = score;
        gameOverScreen.style.display = "flex";
      }

      function gameLoop(timestamp) {
        if (gameState !== "playing") return;

        const dt = (timestamp - lastTime) / 1000; // 转换为秒
        lastTime = timestamp;

        update(dt);
        draw();

        requestAnimationFrame(gameLoop);
      }

      function update(dt) {
        // 生成敌人
        enemySpawnTimer += dt * 1000;
        if (enemySpawnTimer > enemySpawnInterval) {
          // 限制最大敌人数量
          if (enemies.length < 6) {
            enemies.push(new Enemy());
            // 随着分数增加，难度微调（生成或者速度）
            if (enemySpawnInterval > 1000) enemySpawnInterval -= 10;
          }
          enemySpawnTimer = 0;
        }

        // 更新敌人
        enemies.forEach((e) => e.update(dt));
        enemies = enemies.filter((e) => e.active);

        // 更新子弹
        bullets.forEach((b) => b.update(dt));
        bullets = bullets.filter((b) => b.active);

        // 更新例子
        particles.forEach((p) => p.update(dt));
        particles = particles.filter((p) => p.life > 0);
      }

      function draw() {
        // 逻辑大小
        const stageWidth = canvas.width / outputScale;
        const stageHeight = canvas.height / outputScale;

        // 清空
        ctx.clearRect(0, 0, stageWidth, stageHeight);

        // 绘制炮台 (简单的底部居中)
        const turretX = stageWidth / 2;
        const turretY = stageHeight - 40;

        // 炮台底座
        ctx.fillStyle = "#555";
        ctx.fillRect(turretX - 30, turretY, 60, 40);
        // 炮管
        ctx.fillStyle = "#333";
        ctx.fillRect(turretX - 10, turretY - 30, 20, 40);

        // 绘制实体
        enemies.forEach((e) => e.draw(ctx));
        bullets.forEach((b) => b.draw(ctx));
        particles.forEach((p) => p.draw(ctx));

        // 绘制 UI
        ctx.fillStyle = "#333";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`得分: ${score}`, 20, 20);
      }

      /**
       * 输入处理
       */
      function handleInput(e) {
        if (gameState === "gameover") {
          startGame();
          return;
        }

        let clientX, clientY;
        if (e.type === "touchstart") {
          // 阻止默认行为防止双击缩放等
          // e.preventDefault(); // 注意：这可能会阻止某些浏览器的点击，但在canvas游戏中通常需要
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        // 转换坐标到 Canvas 坐标系
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width / outputScale;
        const scaleY = canvas.height / rect.height / outputScale;

        const inputX = (clientX - rect.left) * scaleX;
        const inputY = (clientY - rect.top) * scaleY;

        // 检测是否点击了任何敌人的正确答案
        let shotFired = false;

        // 倒序遍历，优先检测上层的（虽然一般不重叠）
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          const result = enemy.checkInput(inputX, inputY);

          if (result === true) {
            // 答对了！从炮台发射子弹
            const stageWidth = canvas.width / outputScale;
            const stageHeight = canvas.height / outputScale;
            const startX = stageWidth / 2;
            const startY = stageHeight - 60; // 炮口位置

            bullets.push(new Bullet(startX, startY, enemy));
            shotFired = true;
            break; // 一次只射击一个
          } else if (result === false) {
            // 答错了
            // 可选：屏幕抖动或音效
            canvas.style.transform = "translate(5px, 0)";
            setTimeout(() => (canvas.style.transform = "none"), 50);
          }
        }
      }

      // 绑定事件
      canvas.addEventListener("mousedown", handleInput);
      canvas.addEventListener("touchstart", handleInput, { passive: false });

      // 重新开始的点击侦听（因为遮罩层盖住了canvas）
      gameOverScreen.addEventListener("mousedown", () => {
        if (gameState === "gameover") startGame();
      });
      gameOverScreen.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (gameState === "gameover") startGame();
        },
        { passive: false }
      );

      // 启动游戏
      // 添加一个简单的 Polyfill roundRect 以防旧浏览器不支持
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (
          x,
          y,
          w,
          h,
          r
        ) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.beginPath();
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }

      startGame();
    </script>
  </body>
</html>
